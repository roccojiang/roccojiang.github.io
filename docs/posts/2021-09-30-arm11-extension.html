<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Visualisations of Procedural Maze Generation Algorithms in C · Rocco Jiang</title>
        <link rel="stylesheet" href="../css/default.css" />
        <script src="https://kit.fontawesome.com/13b55757d2.js" crossorigin="anonymous"></script>
    </head>
    <body>
        <header>
            <nav>
                <a href="../" class="logo">Rocco Jiang</a>
                <ul>
                    <li><a href="../">About</a></li>
                    <li><a href="../posts.html">Posts</a></li>
                </ul>
            </nav>
        </header>

        <main role="main">
            <h1>Visualisations of Procedural Maze Generation Algorithms in C</h1>
            <article>
    <section class="header">
        Posted on September 30, 2021
        
    </section>
    <section>
        <p>The summer term of <a href="https://www.imperial.ac.uk/computing/current-students/computing/computing-first-year/">Imperial’s first year Computing curriculum</a> ended with a project written in C, completed in groups of four over the span of about three weeks. We were required to implement emulator and assembler programs for a subset of the <a href="https://developer.arm.com/documentation/">ARM instruction set architecture</a>, as well as an open-ended extension (during the last week) which was also required to be written in C.</p>
<p>Our extension was a visualiser for a number of procedural maze generation algorithms, each producing a distinct style of maze with differing solution path characteristics. The program visually conveys the differences between each method, which could aid the understanding of students who are learning the fundamental algorithms behind these generation functions. In this post, I discuss some of the technical details in developing our extension.</p>
<p>For our work on the project, our group was presented with the 2020-21 ARM11 “Best Overall Project” award (with the prize money, Imperial now funds my addiction to building mechanical keyboards). We also had a lot of fun filming our presentation video, which was selected to be shown at the College’s <a href="https://www.imperial.ac.uk/events/136819/undergraduate-virtual-open-week-imperial360-live-department-of-computing/">Undergraduate Virtual Open Week</a>.</p>
<div style="text-align:center">
<p><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/VV_Rhtc2ekA" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen> </iframe></p>
</div>
<p> </p>
<!-- excerpt-end -->
<p>Imperial retains the copyright to the project specification, so I’m not permitted to publicly share or explain our group’s code for the main project. However, as the extension is fully original work, I’m allowed to share our code on a <a href="https://github.com/ethanrange/c-maze-generation">public git repo</a>.</p>
<figure>
<img src="https://github.com/ethanrange/c-maze-generation/raw/master/images/prims.gif" alt="Visualisation of Prim’s algorithm for maze generation. Countless hours were wasted staring at this mesmerising display." /><figcaption aria-hidden="true">Visualisation of Prim’s algorithm for maze generation. Countless hours were wasted staring at this mesmerising display.</figcaption>
</figure>
<h2 id="algorithm-implementations">Algorithm implementations</h2>
<p>The algorithms are all derivatives of classical graph algorithms that Computing students cover earlier in the <a href="https://www.imperial.ac.uk/computing/current-students/courses/40008/">Graphs and Algorithms module</a>. The three maze generation algorithms we implemented were:
1. Randomised Prim’s algorithm
2. Randomised Kruskal’s algorithm
3. Recursive backtracking (randomised depth-first search algorithm)</p>
<p>The Wikipedia page on <a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm">maze generation algorithms</a> provides a concise overview of their implementations. These were fairly trivial to implement and were quickly completed within a single evening during a caffeine-fueled code sprint.</p>
<p>We also implemented a visualisation of <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra’s pathfinding algorithm</a>, to show how these mazes may be solved. Again, this wasn’t difficult to implement, but it was still immensely satisfying to watch the algorithm explore the passageways of our generated mazes, twisting through bends and corners in search of a path to the goal coordinate.</p>
<p><img src="https://github.com/ethanrange/c-maze-generation/raw/master/images/dijkstras.gif" alt="Visualisation of Dijkstra’s algorithm for maze-solving." />{:standalone}</p>
<h2 id="project-structure">Project structure</h2>
<p>The purposes of each source file are as follows:
- <code>main.c</code> – Entry point containing the <code>main</code> function, which sets up the GUI and runs the visualiser loop.
- <code>visualiser.[c|h]</code> – Contains all the functions for handling user input, initiation of algorithms, and drawing
the visualiser.
- <code>prims.[c|h] kruskals.[c|h] recursive_backtrack.[c|h] dijkstras.[c|h]</code> – Implements the initialisation, stepping, and running functions for each respective algorithm.
- <code>utils.[c|h]</code> – Contains type definitions for <code>struct</code>s and implementations of functions common to every algorithm.
- <code>constants.h</code> – Stores useful constants for the visualiser in a single location for easy modification.</p>
<p>Due to the inherent parallels between the algorithms, we were able to take many common features between them (e.g sets, bounds checking, and neighbour identification) and convert them to generic functions, minimising redundant code.</p>
<p><img src="../images/maze-generation-dependencies.svg" alt="Dependency graph for the project." />{:standalone width=“90%”}</p>
<h3 id="use-of-function-pointers">Use of function pointers</h3>
<p>If you were to look at the source files for each algorithm, you’d notice that they mostly follow a very similar structure containing <code>init</code>, <code>step</code>, and <code>run</code> functions. Take <code>prims.h</code> for example (I’ve omitted some of the documentation for brevity):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Initialises the required variables for Prim's algorithm. */</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init_prims<span class="op">(</span>Tile tiles<span class="op">[</span>ROWS<span class="op">][</span>COLS<span class="op">],</span> Player player<span class="op">);</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">/* Performs a single iteration of Prim's algorithm. */</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> step_prims<span class="op">(</span>Tile tiles<span class="op">[</span>ROWS<span class="op">][</span>COLS<span class="op">]);</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">/* Runs the randomised Prim's algorithm. */</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> run_prims<span class="op">(</span>Tile tiles<span class="op">[</span>ROWS<span class="op">][</span>COLS<span class="op">]);</span></span></code></pre></div>
<p>The only algorithm that deviates from this format is the recursive backtrack, which doesn’t have <code>init</code> and <code>step</code> functions since the implementation uses a recursive approach, rather than the iterative approach which allowed step-by-step visualisation for the other algorithms.</p>
<p>This kind of regularity meant that we could take advantage of <a href="https://www.cprogramming.com/tutorial/function-pointers.html">function pointers</a> – one of the features of C that I find really cool and elegant. If we take a look at <code>visualiser.h</code> and <code>visualiser.c</code>, we declare three arrays containing function pointers to each algorithm’s <code>init</code>, <code>step</code>, and <code>run</code> functions:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">void</span> <span class="op">(*</span>InitFuncPtr<span class="op">)(</span>Tile<span class="op">[</span>ROWS<span class="op">][</span>COLS<span class="op">],</span> Player<span class="op">);</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span>  <span class="op">(*</span>StepFuncPtr<span class="op">)(</span>Tile<span class="op">[</span>ROWS<span class="op">][</span>COLS<span class="op">]);</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">bool</span> <span class="op">(*</span>RunFuncPtr<span class="op">)(</span>Tile<span class="op">[</span>ROWS<span class="op">][</span>COLS<span class="op">]);</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">/* Function pointers for stepping, initialising, and running algorithms. */</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">const</span> InitFuncPtr init_functions<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span>NULL<span class="op">,</span> init_prims<span class="op">,</span> init_kruskals<span class="op">,</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>                                              NULL<span class="op">,</span> init_dijkstras<span class="op">};</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">const</span> StepFuncPtr step_functions<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span>NULL<span class="op">,</span> step_prims<span class="op">,</span> step_kruskals<span class="op">,</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                                              NULL<span class="op">,</span> step_dijkstras<span class="op">};</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">const</span> RunFuncPtr run_functions<span class="op">[</span><span class="dv">5</span><span class="op">]</span>   <span class="op">=</span> <span class="op">{</span>NULL<span class="op">,</span> run_prims<span class="op">,</span> run_kruskals<span class="op">,</span> </span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                                              NULL<span class="op">,</span> run_dijkstras<span class="op">};</span></span></code></pre></div>
<p>These arrays store the corresponding function pointer for each algorithm, indexed by the five possible visualiser states as seen in <code>utils.h</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">/** Represents the current state (halted or an algorithm) of the visualiser. */</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">enum</span> RunState <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  HALT<span class="op">,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  PRIMS<span class="op">,</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  KRUSKALS<span class="op">,</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  RECURSIVE_BACKTRACK<span class="op">,</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  DIJKSTRAS</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> RunState<span class="op">;</span></span></code></pre></div>
<p>The handling of multiple algorithms essentially boils down to a simple lookup from an array of function pointers. We see this in the delightfully succinct handling of the <code>run</code> functions in <code>visualiser.c</code> (<code>init</code> and <code>step</code> functions are handled in a similar manner):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">/** Runs the given algorithm. */</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">bool</span> run_algorithm<span class="op">(</span>RunState type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Look up run function pointer from the given algorithm type</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>run_functions<span class="op">[</span>type<span class="op">])</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    SetWindowTitle<span class="op">(</span>run_messages<span class="op">[</span>type<span class="op">]);</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(*</span>run_functions<span class="op">[</span>type<span class="op">])(</span>tiles<span class="op">);</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Return if unsuccessful</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If we were to add more algorithms to the visualiser, we’d merely need to update the function pointer arrays, rather than combing through ugly switch statements in multiple sections of <code>visualiser.c</code>.</p>
<h4 id="one-slight-hitch">One slight hitch</h4>
<p>The recursive backtracking algorithm, being the black sheep of the family, unfortunately complicates things a little as it doesn’t fall into that neat <code>init</code>-<code>step</code>-<code>run</code> pattern. Thus it leaves a blemish on our otherwise beautifully abstracted code:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">/** Initialises and runs the given algorithm. */</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">bool</span> handle_algorithm<span class="op">(</span>RunState type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Initialise algorithm via function pointers</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  init_algorithm<span class="op">(</span>type<span class="op">);</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Handle recursive backtrack separately</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>type <span class="op">==</span> RECURSIVE_BACKTRACK<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    SetWindowTitle<span class="op">(</span>run_messages<span class="op">[</span>type<span class="op">]);</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    run_recursive_backtrack<span class="op">(</span>tiles<span class="op">,</span> player<span class="op">);</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Some other code handling visualiser state</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Run algorithm via function pointers</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> run_algorithm<span class="op">(</span>type<span class="op">);</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Return unsuccessful</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In hindsight, we could’ve taken this into account had we realised sooner. Either way, it’s still much nicer than if we had to handle every algorithm separately with long and painfully verbose switch statements.</p>
<h2 id="takeaways">Takeaways</h2>
<p>This was the first software engineering group project we undertook in our course, and we were given a lot of freedom to implement our code however we wanted. Instead of being given skeleton code files, we were expected to start from a blank slate. We had to carefully consider how to design our codebase, and also experienced using git in a small group setting for the first time. Hours were spent wrangling with uncooperative Makefiles, and many mistakes were made with git merges.</p>
<p>Despite the many challenges we faced, this was a very fun project for everyone involved. We could finally apply what we had learnt throughout the year in a setting where we were unrestricted in our coding approach. It was exhilarating to end the academic year on a project where we could unleash our creativity, and I hope this sentiment is shared by all first year students here in Computing.</p>
<!-- ## Noteworthy challenges
By the time we started work on the extension, our group was well acquainted with C as we had already completed most of the main project by then. Thus, work on the visualiser went rather smoothly, but there are still some challenges we ran into which I felt was worth mentioning (as well as some small annoyances which I just wanted to complain about).

### Flattening nested includes

### Pain with Makefiles

### We kept messing up with git -->
    </section>
</article>

        </main>

        <footer>
            <span class="social">
                <a href="https://github.com/roccojiang" target="_blank" title="GitHub">
                    <i class="fa-brands fa-github"></i>
                </a>
            </span>
            Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
